package components

type SelectOption struct {
	Value string
	Label string
}

type FormSelectProps struct {
	// Core properties
	Name        string
	Label       string
	Options     []SelectOption
	Selected    string
	Placeholder string
	ClassName   string

	// Validation
	Required bool

	// State
	Disabled bool

	// Styling
	Size    InputSize
	Variant InputVariant

	// Messages
	ErrorMsg string
	HelpText string

	// Behavior
	Autocomplete    string
	AriaLabel       string
	AriaDescribedBy string

	// Dowolne atrybuty HTML (w tym hx-* z HTMX)
	Attrs templ.Attributes
}

func (p FormSelectProps) GetSize() InputSize {
	if p.Size == "" {
		return InputSizeMedium
	}
	return p.Size
}

func (p FormSelectProps) GetVariant() InputVariant {
	if p.Variant == "" {
		return InputVariantDefault
	}
	return p.Variant
}

func (p FormSelectProps) GetAutocomplete() string {
	if p.Autocomplete == "" {
		return "off"
	}
	return p.Autocomplete
}

func (p FormSelectProps) GetPlaceholder() string {
	if p.Placeholder == "" {
		return "Wybierz..."
	}
	return p.Placeholder
}

templ FormSelect(props FormSelectProps) {
	<div class="mb-4">
		if props.Label != "" {
			<label
				for={ props.Name }
				class={
					"block text-gray-700 font-medium mb-2",
					templ.KV("text-sm", props.GetSize() == InputSizeSmall),
					templ.KV("text-base", props.GetSize() == InputSizeMedium),
					templ.KV("text-lg", props.GetSize() == InputSizeLarge),
				}
			>
				{ props.Label }
				if props.Required {
					<span class="text-danger ml-1" aria-label="required">*</span>
				}
			</label>
		}
		<select
			id={ props.Name }
			name={ props.Name }
			autocomplete={ props.GetAutocomplete() }
			class={
				"w-full border rounded-md focus:outline-none focus:ring-2 transition-colors bg-white",
				// Sizes
				templ.KV("px-3 py-1 text-sm", props.GetSize() == InputSizeSmall),
				templ.KV("px-4 py-2 text-base", props.GetSize() == InputSizeMedium),
				templ.KV("px-5 py-3 text-lg", props.GetSize() == InputSizeLarge),
				// Variants
				templ.KV("border-gray-300 focus:ring-primary focus:border-primary", props.GetVariant() == InputVariantDefault),
				templ.KV("border-danger focus:ring-danger focus:border-danger", props.GetVariant() == InputVariantError),
				templ.KV("border-success focus:ring-success focus:border-success", props.GetVariant() == InputVariantSuccess),
				// States
				templ.KV("bg-gray-100 cursor-not-allowed opacity-60", props.Disabled),
				// Custom classes
				props.ClassName,
			}
			if props.Required {
				required
			}
			if props.Disabled {
				disabled
			}
			if props.AriaLabel != "" {
				aria-label={ props.AriaLabel }
			}
			if props.AriaDescribedBy != "" {
				aria-describedby={ props.AriaDescribedBy }
			} else if props.ErrorMsg != "" {
				aria-describedby={ props.Name + "-error" }
			} else if props.HelpText != "" {
				aria-describedby={ props.Name + "-help" }
			}
			if props.ErrorMsg != "" {
				aria-invalid="true"
			}
			{ props.Attrs... }
		>
			<option value="">{ props.GetPlaceholder() }</option>
			for _, option := range props.Options {
				<option
					value={ option.Value }
					if option.Value == props.Selected {
						selected
					}
				>
					{ option.Label }
				</option>
			}
		</select>
		if props.ErrorMsg != "" {
			<p id={ props.Name + "-error" } class="mt-1 text-sm text-danger-dark" role="alert">
				{ props.ErrorMsg }
			</p>
		}
		if props.HelpText != "" && props.ErrorMsg == "" {
			<p id={ props.Name + "-help" } class="mt-1 text-sm text-secondary">
				{ props.HelpText }
			</p>
		}
	</div>
}
