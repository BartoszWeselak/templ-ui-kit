package components

type InputSize string
type InputVariant string
type InputType string

const (
	// Sizes
	InputSizeSmall  InputSize = "small"
	InputSizeMedium InputSize = "medium"
	InputSizeLarge  InputSize = "large"

	// Variants
	InputVariantDefault InputVariant = "default"
	InputVariantError   InputVariant = "error"
	InputVariantSuccess InputVariant = "success"

	// Types
	InputTypeText     InputType = "text"
	InputTypeEmail    InputType = "email"
	InputTypePassword InputType = "password"
	InputTypeNumber   InputType = "number"
	InputTypeUrl      InputType = "url"
	InputTypeTel      InputType = "tel"
	InputTypeDate     InputType = "date"
	InputTypeTime     InputType = "time"
	InputTypeSearch   InputType = "search"
)

type FormInputProps struct {
	// Core properties
	Name        string
	Type        string
	Placeholder string
	Label       string
	Value       string
	ClassName   string

	// Validation
	Required  bool
	Pattern   string
	MinLength int
	MaxLength int
	Min       string
	Max       string
	Step      string

	// State
	Disabled bool
	Readonly bool

	// Styling
	Size    InputSize
	Variant InputVariant

	// Messages
	ErrorMsg string
	HelpText string

	// Behavior
	Autocomplete    string
	AriaLabel       string
	AriaDescribedBy string

	// Dowolne atrybuty HTML (w tym hx-* z HTMX)
	Attrs templ.Attributes
}

func (p FormInputProps) GetSize() InputSize {
	if p.Size == "" {
		return InputSizeMedium
	}
	return p.Size
}

func (p FormInputProps) GetVariant() InputVariant {
	if p.Variant == "" {
		return InputVariantDefault
	}
	return p.Variant
}

func (p FormInputProps) GetType() string {
	if p.Type == "" {
		return "text"
	}
	return p.Type
}

func (p FormInputProps) GetAutocomplete() string {
	if p.Autocomplete == "" {
		return "off"
	}
	return p.Autocomplete
}

templ FormInput(props FormInputProps) {
	<div class="mb-4">
		if props.Label != "" {
			<label
				for={ props.Name }
				class={
					"block text-gray-700 font-medium mb-2",
					templ.KV("text-sm", props.GetSize() == InputSizeSmall),
					templ.KV("text-base", props.GetSize() == InputSizeMedium),
					templ.KV("text-lg", props.GetSize() == InputSizeLarge),
				}
			>
				{ props.Label }
				if props.Required {
					<span class="text-danger ml-1" aria-label="required">*</span>
				}
			</label>
		}
		<input
			type={ props.GetType() }
			id={ props.Name }
			name={ props.Name }
			placeholder={ props.Placeholder }
			value={ props.Value }
			autocomplete={ props.GetAutocomplete() }
			class={
				"w-full border rounded-md focus:outline-none focus:ring-2 transition-colors",
				// Sizes
				templ.KV("px-3 py-1 text-sm", props.GetSize() == InputSizeSmall),
				templ.KV("px-4 py-2 text-base", props.GetSize() == InputSizeMedium),
				templ.KV("px-5 py-3 text-lg", props.GetSize() == InputSizeLarge),
				// Variants
				templ.KV("border-gray-300 focus:ring-primary focus:border-primary", props.GetVariant() == InputVariantDefault),
				templ.KV("border-danger focus:ring-danger focus:border-danger", props.GetVariant() == InputVariantError),
				templ.KV("border-success focus:ring-success focus:border-success", props.GetVariant() == InputVariantSuccess),
				// States
				templ.KV("bg-gray-100 cursor-not-allowed opacity-60", props.Disabled),
				templ.KV("bg-gray-50 cursor-default", props.Readonly && !props.Disabled),
				// Custom classes
				props.ClassName,
			}
			if props.Pattern != "" {
				pattern={ props.Pattern }
			}
			if props.MinLength > 0 {
				minlength={ templ.JSONString(props.MinLength) }
			}
			if props.MaxLength > 0 {
				maxlength={ templ.JSONString(props.MaxLength) }
			}
			if props.Min != "" {
				min={ props.Min }
			}
			if props.Max != "" {
				max={ props.Max }
			}
			if props.Step != "" {
				step={ props.Step }
			}
			if props.Required {
				required
			}
			if props.Disabled {
				disabled
			}
			if props.Readonly {
				readonly
			}
			if props.AriaLabel != "" {
				aria-label={ props.AriaLabel }
			}
			if props.AriaDescribedBy != "" {
				aria-describedby={ props.AriaDescribedBy }
			} else if props.ErrorMsg != "" {
				aria-describedby={ props.Name + "-error" }
			} else if props.HelpText != "" {
				aria-describedby={ props.Name + "-help" }
			}
			if props.ErrorMsg != "" {
				aria-invalid="true"
			}
			{ props.Attrs... }
		/>
		if props.ErrorMsg != "" {
			<p id={ props.Name + "-error" } class="mt-1 text-sm text-danger-dark" role="alert">
				{ props.ErrorMsg }
			</p>
		}
		if props.HelpText != "" && props.ErrorMsg == "" {
			<p id={ props.Name + "-help" } class="mt-1 text-sm text-secondary">
				{ props.HelpText }
			</p>
		}
	</div>
}
